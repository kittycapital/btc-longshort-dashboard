<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>ë¡±ìˆ ë¹„ìœ¨ ëŒ€ì‹œë³´ë“œ</title>
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@300;400;500;600;700&family=JetBrains+Mono:wght@400;500;600&display=swap" rel="stylesheet">
<style>
:root {
  --bg-primary: #08080d;
  --bg-card: #101018;
  --bg-elevated: #1a1a28;
  --border: #1c1c2e;
  --border-glow: #2a2a45;
  --text-primary: #e8e8f0;
  --text-secondary: #8888a8;
  --text-muted: #555570;
  --green: #00d68f;
  --green-dim: #00d68f33;
  --red: #ff3d71;
  --red-dim: #ff3d7133;
  --blue: #3366ff;
  --orange: #f0a030;
}
* { margin:0; padding:0; box-sizing:border-box; }
body { background: var(--bg-primary); color: var(--text-primary); font-family: 'Noto Sans KR', sans-serif; line-height: 1.6; scrollbar-width: none; -ms-overflow-style: none; }
body::-webkit-scrollbar { display: none; }

/* Header */
.header { padding: 24px 28px 16px; border-bottom: 1px solid var(--border); background: linear-gradient(180deg, #0c0c14 0%, var(--bg-primary) 100%); }
.header-top { display: flex; align-items: center; justify-content: space-between; flex-wrap: wrap; gap: 12px; }
.header h1 { font-size: 20px; font-weight: 700; display: flex; align-items: center; gap: 10px; }
.header-meta { display: flex; align-items: center; gap: 16px; font-size: 11px; color: var(--text-muted); }
.header-meta .dot { width:6px;height:6px;background:var(--green);border-radius:50%;display:inline-block;margin-right:4px;animation:pulse 2s infinite; }
@keyframes pulse{0%,100%{opacity:1}50%{opacity:0.4}}
.status-bar { display:flex;gap:16px;margin-top:8px;font-size:11px;color:var(--text-muted);flex-wrap:wrap; }
.status-item { display:flex;align-items:center;gap:4px; }
.ok { color: var(--green); }
.loading-s { color: var(--orange); }
.fail { color: var(--red); }
.period-selector { display:flex;gap:4px;margin-top:12px;overflow-x:auto;-webkit-overflow-scrolling:touch;scrollbar-width:none; }
.period-selector::-webkit-scrollbar{display:none}
.period-btn { padding:6px 16px;border:1px solid var(--border);border-radius:6px;background:transparent;color:var(--text-secondary);font-size:12px;font-family:'JetBrains Mono',monospace;cursor:pointer;transition:all 0.2s;white-space:nowrap;flex-shrink:0; }
.period-btn:hover { border-color:var(--border-glow);color:var(--text-primary); }
.period-btn.active { background:var(--blue);color:#fff;border-color:var(--blue);font-weight:600; }

/* Layout */
.dashboard { max-width:1400px;margin:0 auto;padding:20px;display:flex;flex-direction:column;gap:16px; }

/* Signal */
.signal-banner { display:grid;grid-template-columns:1fr 1fr;gap:12px; }
.signal-box { background:var(--bg-card);border:1px solid var(--border);border-radius:10px;padding:16px 18px;overflow:hidden; }
.signal-box h3 { font-size:12px;font-weight:600;margin-bottom:10px;display:flex;align-items:center;gap:6px; }
.signal-box.long-box h3 { color:var(--green); }
.signal-box.short-box h3 { color:var(--red); }
.signal-item { display:flex;align-items:center;justify-content:space-between;padding:6px 0;border-bottom:1px solid var(--border);font-size:13px;cursor:pointer; }
.signal-item:last-child { border-bottom:none; }
.signal-item:hover { background:var(--bg-elevated); }
.signal-item .coin-info { display:flex;align-items:center;gap:8px; }
.signal-item .coin-info img { width:20px;height:20px;border-radius:50%; }
.signal-item .coin-symbol { font-family:'JetBrains Mono',monospace;font-weight:600;font-size:13px; }
.ratio-bar .bar-wrap { width:80px;height:6px;background:var(--bg-primary);border-radius:3px;overflow:hidden; }
.ratio-bar .bar-fill { height:100%;border-radius:3px;transition:width 0.5s; }
.signal-item .ratio-bar { display:flex;align-items:center;gap:6px; }
.ratio-bar .pct { font-family:'JetBrains Mono',monospace;font-size:12px;font-weight:600;min-width:42px;text-align:right; }

/* Table */
.section { background:var(--bg-card);border:1px solid var(--border);border-radius:10px;padding:18px; }
.section-title { font-size:14px;font-weight:600;margin-bottom:4px;display:flex;align-items:center;gap:8px; }
.section-subtitle { font-size:11px;color:var(--text-muted);margin-bottom:14px; }
.table-wrap { overflow-x:auto;-webkit-overflow-scrolling:touch; }
.table-wrap::-webkit-scrollbar{height:4px}
.table-wrap::-webkit-scrollbar-thumb{background:var(--border-glow);border-radius:2px}
.coin-table { width:100%;border-collapse:collapse;font-size:13px;min-width:760px; }
.coin-table th { padding:8px 10px;font-size:10px;font-weight:500;color:var(--text-muted);text-transform:uppercase;letter-spacing:0.5px;border-bottom:1px solid var(--border);text-align:right;white-space:nowrap;cursor:pointer;user-select:none; }
.coin-table th:first-child,.coin-table th:nth-child(2){text-align:left}
.coin-table th:hover{color:var(--text-secondary)}
.coin-table th.sorted{color:var(--blue)}
.coin-table td { padding:10px;border-bottom:1px solid var(--border);text-align:right;font-family:'JetBrains Mono',monospace;font-size:13px;white-space:nowrap;color:var(--text-primary); }
.coin-table td:first-child{text-align:center;color:var(--text-muted);font-size:11px;width:30px}
.coin-table td:nth-child(2){text-align:left;font-family:'Noto Sans KR',sans-serif}
.coin-table tr:hover td{background:var(--bg-elevated)}
.coin-table tr{cursor:pointer}
.coin-cell { display:flex;align-items:center;gap:8px; }
.coin-cell img { width:22px;height:22px;border-radius:50%; }
.coin-cell .symbol { font-family:'JetBrains Mono',monospace;font-weight:600;font-size:13px;color:var(--text-primary); }
.coin-cell .name { color:var(--text-secondary);font-size:11px;margin-left:4px; }
.pos{color:var(--green)}.neg{color:var(--red)}
.long-pct{color:var(--green);font-weight:500}
.signal-badge { display:inline-block;padding:2px 8px;border-radius:4px;font-size:10px;font-weight:600;font-family:'Noto Sans KR',sans-serif; }
.signal-badge.extreme_long{background:var(--green-dim);color:var(--green)}
.signal-badge.long{background:#00d68f18;color:#33e0a8}
.signal-badge.extreme_short{background:var(--red-dim);color:var(--red)}
.signal-badge.short{background:#ff3d7118;color:#ff6b8a}
.signal-badge.neutral{background:transparent;color:var(--text-muted)}
.ls-bar{display:flex;align-items:center;gap:4px}
.ls-bar .bar-track{width:60px;height:5px;background:var(--red-dim);border-radius:3px;overflow:hidden}
.ls-bar .bar-long{height:100%;background:var(--green);border-radius:3px 0 0 3px;transition:width 0.4s}
.lc{color:var(--text-muted);font-size:11px;font-style:italic}

/* Chart */
.chart-container{position:relative;width:100%;height:320px}
.detail-header{display:flex;align-items:center;justify-content:space-between;flex-wrap:wrap;gap:10px;margin-bottom:14px}
.detail-coin{display:flex;align-items:center;gap:10px;font-size:18px;font-weight:700}
.detail-coin img{width:28px;height:28px;border-radius:50%}
.detail-stats{display:flex;gap:20px;font-size:12px}
.detail-stats .stat{display:flex;flex-direction:column;align-items:center}
.detail-stats .stat-label{font-size:10px;color:var(--text-muted);text-transform:uppercase}
.detail-stats .stat-value{font-family:'JetBrains Mono',monospace;font-weight:600;font-size:14px}

.footer{text-align:center;padding:20px;font-size:10px;color:var(--text-muted);border-top:1px solid var(--border)}
.loading{display:flex;align-items:center;justify-content:center;height:200px;color:var(--text-muted);font-size:14px}
.spinner{width:18px;height:18px;border:2px solid var(--border);border-top-color:var(--blue);border-radius:50%;animation:spin 0.8s linear infinite;margin-right:10px}
@keyframes spin{to{transform:rotate(360deg)}}

@media(max-width:900px){
  .header{padding:16px 14px 12px}.dashboard{padding:12px;gap:12px}.section{padding:14px}
  .chart-container{height:260px}.signal-banner{grid-template-columns:1fr}
}
@media(max-width:500px){
  .header h1{font-size:17px}.coin-table{font-size:12px}
  .period-btn{padding:8px 14px;font-size:13px}.chart-container{height:230px}
  .detail-coin{font-size:16px}.detail-stats .stat-value{font-size:12px}
}
</style>
</head>
<body>

<div class="header">
  <div class="header-top">
    <h1><span>ğŸ“Š</span> ë¡±ìˆ ë¹„ìœ¨ ëŒ€ì‹œë³´ë“œ</h1>
    <div class="header-meta">
      <span><span class="dot"></span> ì‹¤ì‹œê°„</span>
      <span id="lastUpdated">-</span>
    </div>
  </div>
  <div class="status-bar">
    <div class="status-item">ì½”ì¸ëª©ë¡: <span id="statusCoins" class="loading-s">ë¡œë”© ì¤‘</span></div>
    <div class="status-item">Binance: <span id="statusBinance" class="loading-s">ë¡œë”© ì¤‘</span></div>
    <div class="status-item">Bybit: <span id="statusBybit" class="loading-s">ë¡œë”© ì¤‘</span></div>
  </div>
  <div class="period-selector">
    <button class="period-btn active" data-period="1">1ì¼</button>
    <button class="period-btn" data-period="7">1ì£¼</button>
    <button class="period-btn" data-period="30">1ë‹¬</button>
  </div>
</div>

<div class="dashboard">
  <div class="signal-banner" id="signalBanner">
    <div class="loading"><div class="spinner"></div>ë°ì´í„° ë¡œë”© ì¤‘...</div>
  </div>
  <div class="section">
    <div class="section-title">ğŸ“‹ ì „ì²´ ì½”ì¸ ë¡±ìˆ ë¹„ìœ¨</div>
    <div class="section-subtitle">Binance Â· Bybit ì‹¤ì‹œê°„ ë¡±/ìˆ ë¹„ìœ¨ Â· ì½”ì¸ì„ í´ë¦­í•˜ë©´ ìƒì„¸ ì°¨íŠ¸</div>
    <div class="table-wrap" id="coinTableWrap">
      <div class="loading"><div class="spinner"></div>ë°ì´í„° ë¡œë”© ì¤‘...</div>
    </div>
  </div>
  <div class="section" id="detailSection" style="display:none;">
    <div class="detail-header" id="detailHeader"></div>
    <div class="chart-container" id="chartContainer">
      <canvas id="detailChart"></canvas>
    </div>
  </div>
</div>

<div class="footer">
  ë°ì´í„°: Binance Â· Bybit (ë¸Œë¼ìš°ì € ì‹¤ì‹œê°„) Â· CoinGecko (ì½”ì¸ ëª©ë¡) Â· íˆ¬ì ì¡°ì–¸ì´ ì•„ë‹™ë‹ˆë‹¤
</div>

<script>
const isMobile = window.innerWidth <= 600;
let allCoins = [];
let binanceData = {};   // symbol -> { long, short, ratio }
let bybitData = {};     // symbol -> { long, short, ratio }
let binanceDone = false, bybitDone = false;
let selectedCoin = null;
let detailChart = null;
let currentSort = { col: 'market_cap_rank', dir: 'asc' };

if (typeof Chart !== 'undefined') {
  Chart.defaults.color = '#8888a8';
  Chart.defaults.borderColor = '#1c1c2e';
  Chart.defaults.font.family = "'JetBrains Mono','Noto Sans KR',monospace";
  Chart.defaults.font.size = isMobile ? 10 : 11;
}

// â”€â”€â”€ Helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const fmtPrice = (p) => {
  if (!p) return '-';
  if (p >= 1000) return '$' + p.toLocaleString('en-US',{maximumFractionDigits:0});
  if (p >= 1) return '$' + p.toFixed(2);
  if (p >= 0.01) return '$' + p.toFixed(4);
  return '$' + p.toFixed(6);
};
const fmt = (v,d=1) => v!=null?(v>0?'+':'')+v.toFixed(d):'-';
const round = Math.round;

function getBestLong(symbol) {
  const bn = binanceData[symbol];
  const by = bybitData[symbol];
  if (bn && by) return { long: bn.long, short: bn.short, src: 'both' };
  if (bn) return { long: bn.long, short: bn.short, src: 'binance' };
  if (by) return { long: by.long, short: by.short, src: 'bybit' };
  return null;
}

function getSignal(longPct) {
  if (longPct >= 0.70) return { signal: 'extreme_long', text: 'ğŸŸ¢ ê·¹ë‹¨ ë¡±' };
  if (longPct >= 0.60) return { signal: 'long', text: 'ë¡± ê³¼ë°€' };
  if (longPct <= 0.30) return { signal: 'extreme_short', text: 'ğŸ”´ ê·¹ë‹¨ ìˆ' };
  if (longPct <= 0.40) return { signal: 'short', text: 'ìˆ ê³¼ë°€' };
  return { signal: 'neutral', text: '-' };
}

// â”€â”€â”€ Binance Client Fetch â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async function fetchBinance(symbol) {
  try {
    const r = await fetch(`https://fapi.binance.com/futures/data/globalLongShortAccountRatio?symbol=${symbol}USDT&period=1h&limit=1`);
    if (!r.ok) return null;
    const d = await r.json();
    if (d && d.length > 0) return { long: +d[0].longAccount, short: +d[0].shortAccount, ratio: +d[0].longShortRatio };
  } catch(e) {}
  return null;
}

async function fetchBinanceHistory(symbol, period='4h', limit=180) {
  try {
    const r = await fetch(`https://fapi.binance.com/futures/data/globalLongShortAccountRatio?symbol=${symbol}USDT&period=${period}&limit=${limit}`);
    if (!r.ok) return [];
    const d = await r.json();
    return d.map(x => ({
      timestamp: new Date(x.timestamp).toISOString(),
      long: +x.longAccount, short: +x.shortAccount
    }));
  } catch(e) { return []; }
}

async function fetchAllBinance(coins) {
  const el = document.getElementById('statusBinance');
  el.textContent = '0/' + coins.length; el.className = 'loading-s';
  let ok = 0;
  for (let i = 0; i < coins.length; i += 5) {
    const batch = coins.slice(i, i+5);
    const results = await Promise.all(batch.map(c => fetchBinance(c.symbol)));
    results.forEach((r,j) => { if(r){ binanceData[batch[j].symbol]=r; ok++; }});
    el.textContent = `${Math.min(i+5,coins.length)}/${coins.length}`;
    rerender();
    if (i+5 < coins.length) await new Promise(r=>setTimeout(r,250));
  }
  binanceDone = true;
  el.textContent = ok > 0 ? `âœ“ ${ok}ê°œ` : 'âœ— ì°¨ë‹¨';
  el.className = ok > 0 ? 'ok' : 'fail';
  rerender();
}

// â”€â”€â”€ Bybit Client Fetch â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async function fetchBybit(symbol) {
  try {
    const r = await fetch(`https://api.bybit.com/v5/market/account-ratio?category=linear&symbol=${symbol}USDT&period=1h&limit=1`);
    if (!r.ok) return null;
    const d = await r.json();
    if (d.retCode === 0) {
      const lst = d.result?.list;
      if (lst && lst.length > 0) {
        const buy = +lst[0].buyRatio, sell = +lst[0].sellRatio;
        return { long: buy, short: sell, ratio: +(buy/Math.max(sell,0.001)).toFixed(4) };
      }
    }
  } catch(e) {}
  return null;
}

async function fetchBybitHistory(symbol, period='4h', limit=200) {
  try {
    const r = await fetch(`https://api.bybit.com/v5/market/account-ratio?category=linear&symbol=${symbol}USDT&period=${period}&limit=${limit}`);
    if (!r.ok) return [];
    const d = await r.json();
    if (d.retCode === 0) {
      const lst = d.result?.list || [];
      return lst.map(x => ({
        timestamp: new Date(+x.timestamp).toISOString(),
        long: +x.buyRatio, short: +x.sellRatio
      })).reverse();
    }
  } catch(e) {}
  return [];
}

async function fetchAllBybit(coins) {
  const el = document.getElementById('statusBybit');
  el.textContent = '0/' + coins.length; el.className = 'loading-s';
  let ok = 0;
  for (let i = 0; i < coins.length; i += 5) {
    const batch = coins.slice(i, i+5);
    const results = await Promise.all(batch.map(c => fetchBybit(c.symbol)));
    results.forEach((r,j) => { if(r){ bybitData[batch[j].symbol]=r; ok++; }});
    el.textContent = `${Math.min(i+5,coins.length)}/${coins.length}`;
    rerender();
    if (i+5 < coins.length) await new Promise(r=>setTimeout(r,200));
  }
  bybitDone = true;
  el.textContent = ok > 0 ? `âœ“ ${ok}ê°œ` : 'âœ— ì°¨ë‹¨';
  el.className = ok > 0 ? 'ok' : 'fail';
  rerender();
}

// â”€â”€â”€ Load & Init â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async function init() {
  try {
    const resp = await fetch('data/coins.json');
    const data = await resp.json();
    allCoins = data.coins;
    document.getElementById('statusCoins').textContent = `âœ“ ${allCoins.length}ê°œ`;
    document.getElementById('statusCoins').className = 'ok';
    document.getElementById('lastUpdated').textContent =
      'ì½”ì¸ëª©ë¡: ' + new Date(data.updated_at).toLocaleString('ko-KR',{timeZone:'Asia/Seoul'});
    rerender();

    // Fetch exchange data in parallel
    fetchAllBinance(allCoins);
    fetchAllBybit(allCoins);
  } catch(e) {
    document.getElementById('signalBanner').innerHTML =
      '<div class="loading" style="color:var(--red)">coins.json ë¡œë”© ì‹¤íŒ¨</div>';
    document.getElementById('statusCoins').textContent = 'âœ— ì‹¤íŒ¨';
    document.getElementById('statusCoins').className = 'fail';
  }
}

function rerender() {
  renderSignalBanner();
  renderCoinTable();
}

// â”€â”€â”€ Signal Banner â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function renderSignalBanner() {
  const withData = allCoins.filter(c => getBestLong(c.symbol));
  if (withData.length === 0) {
    document.getElementById('signalBanner').innerHTML =
      '<div class="loading"><div class="spinner"></div>ê±°ë˜ì†Œ ë°ì´í„° ë¡œë”© ì¤‘...</div>';
    return;
  }
  const sorted = [...withData].sort((a,b) => (getBestLong(b.symbol)?.long||0.5) - (getBestLong(a.symbol)?.long||0.5));
  const topLong = sorted.slice(0, 5);
  const topShort = sorted.slice(-5).reverse();

  document.getElementById('signalBanner').innerHTML = `
    <div class="signal-box long-box">
      <h3>ğŸŸ¢ ë¡± ê³¼ë°€ TOP 5</h3>
      ${topLong.map(c => sigItem(c,'long')).join('')}
    </div>
    <div class="signal-box short-box">
      <h3>ğŸ”´ ìˆ ê³¼ë°€ TOP 5</h3>
      ${topShort.map(c => sigItem(c,'short')).join('')}
    </div>`;
}

function sigItem(coin, type) {
  const best = getBestLong(coin.symbol);
  if (!best) return '';
  const pctVal = type==='long' ? best.long : best.short;
  const color = type==='long' ? 'var(--green)' : 'var(--red)';
  return `<div class="signal-item" onclick="selectCoin('${coin.symbol}')">
    <div class="coin-info">
      <img src="${coin.image}" onerror="this.style.display='none'">
      <span class="coin-symbol">${coin.symbol}</span>
    </div>
    <div class="ratio-bar">
      <div class="bar-wrap"><div class="bar-fill" style="width:${pctVal*100}%;background:${color}"></div></div>
      <span class="pct" style="color:${color}">${(pctVal*100).toFixed(1)}%</span>
    </div>
  </div>`;
}

// â”€â”€â”€ Coin Table â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function renderCoinTable() {
  const coins = sortCoins([...allCoins], currentSort.col, currentSort.dir);
  const si=(c)=>currentSort.col===c?(currentSort.dir==='asc'?' â†‘':' â†“'):'';
  const sc=(c)=>currentSort.col===c?'sorted':'';

  let h = `<table class="coin-table"><thead><tr>
    <th onclick="doSort('market_cap_rank')" class="${sc('market_cap_rank')}">#${si('market_cap_rank')}</th>
    <th onclick="doSort('symbol')" class="${sc('symbol')}">ì½”ì¸${si('symbol')}</th>
    <th onclick="doSort('price')" class="${sc('price')}">ê°€ê²©${si('price')}</th>
    <th onclick="doSort('price_change_24h')" class="${sc('price_change_24h')}">24h${si('price_change_24h')}</th>
    <th onclick="doSort('binance_long')" class="${sc('binance_long')}">Binance${si('binance_long')}</th>
    <th onclick="doSort('bybit_long')" class="${sc('bybit_long')}">Bybit${si('bybit_long')}</th>
    <th>ë¡±/ìˆ</th>
    <th onclick="doSort('signal')" class="${sc('signal')}">ì‹œê·¸ë„${si('signal')}</th>
  </tr></thead><tbody>`;

  coins.forEach((c,i) => {
    const bn = binanceData[c.symbol];
    const by = bybitData[c.symbol];
    const best = getBestLong(c.symbol);
    const barLong = best?.long || 0.5;
    const sig = getSignal(best?.long || 0.5);
    const pc = (c.price_change_24h||0)>=0?'pos':'neg';

    h += `<tr onclick="selectCoin('${c.symbol}')">
      <td>${c.market_cap_rank||i+1}</td>
      <td><div class="coin-cell">
        <img src="${c.image}" onerror="this.style.display='none'">
        <span class="symbol">${c.symbol}</span>
        <span class="name">${c.name||''}</span>
      </div></td>
      <td>${fmtPrice(c.price)}</td>
      <td class="${pc}">${fmt(c.price_change_24h,1)}%</td>
      <td>${bn?`<span class="long-pct">${(bn.long*100).toFixed(1)}%</span>`:(!binanceDone?'<span class="lc">Â·Â·Â·</span>':'<span class="lc">-</span>')}</td>
      <td>${by?`<span class="long-pct">${(by.long*100).toFixed(1)}%</span>`:(!bybitDone?'<span class="lc">Â·Â·Â·</span>':'<span class="lc">-</span>')}</td>
      <td><div class="ls-bar"><div class="bar-track"><div class="bar-long" style="width:${barLong*100}%"></div></div></div></td>
      <td><span class="signal-badge ${best?sig.signal:'neutral'}">${best?sig.text:'-'}</span></td>
    </tr>`;
  });

  h += '</tbody></table>';
  document.getElementById('coinTableWrap').innerHTML = h;
}

// â”€â”€â”€ Sort â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function sortCoins(coins, col, dir) {
  return coins.sort((a,b) => {
    let va,vb;
    switch(col) {
      case 'market_cap_rank': va=a.market_cap_rank||999;vb=b.market_cap_rank||999;break;
      case 'symbol': return dir==='asc'?a.symbol.localeCompare(b.symbol):b.symbol.localeCompare(a.symbol);
      case 'price': va=a.price||0;vb=b.price||0;break;
      case 'price_change_24h': va=a.price_change_24h||0;vb=b.price_change_24h||0;break;
      case 'binance_long': va=binanceData[a.symbol]?.long||0.5;vb=binanceData[b.symbol]?.long||0.5;break;
      case 'bybit_long': va=bybitData[a.symbol]?.long||0.5;vb=bybitData[b.symbol]?.long||0.5;break;
      case 'signal': va=Math.abs((getBestLong(a.symbol)?.long||0.5)-0.5);vb=Math.abs((getBestLong(b.symbol)?.long||0.5)-0.5);break;
      default: va=0;vb=0;
    }
    return dir==='asc'?va-vb:vb-va;
  });
}

function doSort(col) {
  if (currentSort.col===col) currentSort.dir=currentSort.dir==='asc'?'desc':'asc';
  else { currentSort.col=col; currentSort.dir=col==='market_cap_rank'?'asc':'desc'; }
  renderCoinTable();
}

// â”€â”€â”€ Detail Chart â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async function selectCoin(symbol) {
  selectedCoin = symbol;
  const coin = allCoins.find(c=>c.symbol===symbol);
  if (!coin) return;

  const section = document.getElementById('detailSection');
  section.style.display = 'block';

  const bn = binanceData[symbol];
  const by = bybitData[symbol];

  document.getElementById('detailHeader').innerHTML = `
    <div class="detail-coin">
      <img src="${coin.image}" onerror="this.style.display='none'">
      ${symbol} ë¡±ìˆ ì¶”ì´
    </div>
    <div class="detail-stats">
      <div class="stat"><span class="stat-label">Binance ë¡±</span>
        <span class="stat-value long-pct">${bn?(bn.long*100).toFixed(1)+'%':'-'}</span></div>
      <div class="stat"><span class="stat-label">Bybit ë¡±</span>
        <span class="stat-value long-pct">${by?(by.long*100).toFixed(1)+'%':'-'}</span></div>
      <div class="stat"><span class="stat-label">ê°€ê²©</span>
        <span class="stat-value">${fmtPrice(coin.price)}</span></div>
    </div>`;

  const chartDiv = document.getElementById('chartContainer');
  chartDiv.innerHTML = '<div class="loading"><div class="spinner"></div>íˆìŠ¤í† ë¦¬ ë¡œë”© ì¤‘...</div>';
  section.scrollIntoView({behavior:'smooth',block:'start'});

  // Fetch history from both exchanges
  const periodDays = parseInt(document.querySelector('.period-btn.active').dataset.period);
  const limit = periodDays <= 1 ? 24 : periodDays <= 7 ? 42 : 180;
  const period = periodDays <= 1 ? '1h' : '4h';

  const [bnHist, byHist] = await Promise.all([
    fetchBinanceHistory(symbol, period, limit),
    fetchBybitHistory(symbol, period, limit)
  ]);

  // Use whichever has data (prefer Binance for longer history)
  const hist = bnHist.length > 0 ? bnHist : byHist;
  const histSource = bnHist.length > 0 ? 'Binance' : 'Bybit';

  if (hist.length === 0) {
    chartDiv.innerHTML = '<div class="loading">íˆìŠ¤í† ë¦¬ ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤</div>';
    return;
  }

  chartDiv.innerHTML = '<canvas id="detailChart"></canvas>';

  const cutoff = new Date();
  cutoff.setDate(cutoff.getDate() - periodDays);
  const filtered = hist.filter(h => new Date(h.timestamp) >= cutoff);

  const labels = filtered.map(h => {
    const d = new Date(h.timestamp);
    return `${d.getMonth()+1}/${d.getDate()} ${String(d.getHours()).padStart(2,'0')}:00`;
  });

  if (detailChart) detailChart.destroy();
  detailChart = new Chart(document.getElementById('detailChart'), {
    type: 'line',
    data: {
      labels,
      datasets: [
        {
          label: `${histSource} ë¡±`,
          data: filtered.map(h=>h.long*100),
          borderColor:'#00d68f', backgroundColor:'#00d68f20',
          fill:true,tension:0.3,pointRadius:0,pointHoverRadius:4,borderWidth:2,
        },
        {
          label: `${histSource} ìˆ`,
          data: filtered.map(h=>h.short*100),
          borderColor:'#ff3d71', backgroundColor:'#ff3d7120',
          fill:true,tension:0.3,pointRadius:0,pointHoverRadius:4,borderWidth:2,
        }
      ]
    },
    options: {
      responsive:true, maintainAspectRatio:false,
      interaction:{intersect:false,mode:'index'},
      plugins: {
        legend:{labels:{boxWidth:isMobile?8:12,padding:isMobile?8:14}},
        tooltip:{backgroundColor:'#1a1a28',borderColor:'#2a2a45',borderWidth:1,
          callbacks:{label:(it)=>`${it.dataset.label}: ${it.raw.toFixed(1)}%`}}
      },
      scales: {
        x:{grid:{display:false},ticks:{maxRotation:0,autoSkip:true,maxTicksLimit:isMobile?5:10}},
        y:{grid:{color:'#1c1c2e44'},ticks:{callback:v=>v+'%'},min:20,max:80}
      }
    }
  });
}

// â”€â”€â”€ Period â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
document.querySelectorAll('.period-btn').forEach(btn => {
  btn.addEventListener('click', () => {
    document.querySelector('.period-btn.active').classList.remove('active');
    btn.classList.add('active');
    if (selectedCoin) selectCoin(selectedCoin);
  });
});

// â”€â”€â”€ Start â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
init();

// â”€â”€â”€ imweb iframe â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function postHeight(){const h=document.documentElement.scrollHeight;window.parent.postMessage({type:'resize',height:h},'*');window.parent.postMessage({height:h},'*');window.parent.postMessage(JSON.stringify({event:'setHeight',height:h}),'*');}
new ResizeObserver(()=>postHeight()).observe(document.body);
window.addEventListener('load',()=>setTimeout(postHeight,500));
setInterval(postHeight, 2000);
</script>
</body>
</html>
